<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>srvyuRu-metaSurvey</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mauro Loprete" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/xaringanExtra-banner/banner.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-banner/banner.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# srvyuRu-metaSurvey
]
.subtitle[
## RLadies &amp; Guru
]
.author[
### Mauro Loprete
]
.date[
### 29 de noviembre 2022
]

---





class: header_background

# Guía

- ### Metaprogramación

--

- ### Justificación

--

  - #### Dependencias de R
      - **R6**
      - **glue**
      - **httr**
      - **survey**
      - **foreign**

--

- ### Ejemplos

--

- ### srvyuRu a metaSurvey

--

- ### metaSurvey versión públcia y CRAN

---

class: header_background

# Metaprogramación


- ## Code is data


.panelset[
.panel[.panel-name[ech]
.scroll-box-12[


```r
employment &lt;- function(data = ech::toy_ech_2018,
                       pobpcoac = "pobpcoac") {

# checks ---
  assertthat::assert_that(is.data.frame(data), msg = glue::glue("Sorry... :( \n  is not a data.frame"))
  assertthat::assert_that(pobpcoac %in% names(data), msg = glue::glue("Sorry... :( \n  {popbcoac} is not in data"))

# variables ---
  data &lt;- data %&gt;% dplyr::mutate(pea = ifelse(pobpcoac %in% 2:5, 1, 0),
                          pet = ifelse(pobpcoac != 1, 1, 0),
                          po  = ifelse(pobpcoac == 2, 1, 0),
                          pd  = ifelse(pobpcoac %in% 3:5, 1, 0),
                          pea = haven::labelled(pea, labels = c("Si" = 1, "No" = 0),
                                                label = "Poblacion economicamente activa"),
                          pet = haven::labelled(pet, labels = c("Si" = 1, "No" = 0),
                                                label = "Poblacion en edad de trabajar"),
                          po = haven::labelled(po, labels = c("Si" = 1, "No" = 0),
                                               label = "Poblacion ocupada"),
                          pd = haven::labelled(pd, labels = c("Si" = 1, "No" = 0),
                                               label = "Poblacion desocupada")
  )

  message("Variables have been created: \n \t pea (Poblacion economicamente activa);
         pet (Poblacion en edad de trabajar);
         po (Poblacion ocupada) &amp;
         pd (Poblacion desocupada)")
  return(data)
}
```

]

Tomado de [github/ech] (https://github.com/calcita/ech/blob/master/R/employment.R)

]

.panel[.panel-name[eph]
.scroll-box-12[

```r
calculate_poverty &lt;- function(base,basket,print_summary=TRUE,window = "quarter",group_vars =c()){

  base &lt;- base %&gt;%
    dplyr::mutate(periodo = paste(ANO4, TRIMESTRE, sep='.')) %&gt;%
    dplyr::left_join(., adulto_equivalente, by = c("CH04", "CH06")) %&gt;%
    dplyr::left_join(., basket, by = c('REGION'="codigo", "periodo")) %&gt;%
    dplyr::group_by(CODUSU, NRO_HOGAR, periodo)                          %&gt;%
    dplyr::mutate(adequi_hogar = sum(adequi))                            %&gt;%
    dplyr::ungroup() %&gt;%
    dplyr::mutate(CBA_hogar = CBA*adequi_hogar,
                  CBT_hogar = CBT*adequi_hogar,
                  situacion = dplyr::case_when(ITF&lt;CBA_hogar            ~ 'indigente',
                                               ITF&gt;=CBA_hogar &amp; ITF&lt;CBT_hogar ~ 'pobre',
                                               ITF&gt;=CBT_hogar           ~ 'no_pobre'),
                  situacion = dplyr::case_when(PONDIH==0 ~ NA_character_, #excluyo los casos que no tienen respuesta en ITF
                                               TRUE ~ situacion)) %&gt;%
    dplyr::select(-adequi,-periodo,-CBA, -CBT)

  if (print_summary) {
    if(window == "quarter"){
      Pobreza_resumen &lt;- base %&gt;%
        dplyr::group_by(ANO4,TRIMESTRE,dplyr::across(c({{group_vars}}))) %&gt;%
        dplyr::summarise(Tasa_pobreza    = sum(PONDIH[situacion %in% c('pobre', 'indigente')],na.rm = TRUE)/
                           sum(PONDIH,na.rm = TRUE),
                         Tasa_indigencia = sum(PONDIH[situacion == 'indigente'],na.rm = TRUE)/
                           sum(PONDIH,na.rm = TRUE))
    }
    else {
      Pobreza_resumen &lt;- base %&gt;%
        dplyr::mutate(SEMESTRE = ifelse(TRIMESTRE %in% c(1,2),yes = 1,no = 2)) %&gt;%
        dplyr::group_by(ANO4,SEMESTRE,dplyr::across(c({{group_vars}}))) %&gt;%
        dplyr::summarise(Tasa_pobreza    = sum(PONDIH[situacion %in% c('pobre', 'indigente')],na.rm = TRUE)/
                           sum(PONDIH,na.rm = TRUE),
                         Tasa_indigencia = sum(PONDIH[situacion == 'indigente'],na.rm = TRUE)/
                           sum(PONDIH,na.rm = TRUE))

    }

    print(Pobreza_resumen)

  }
  return(base)
}
```
]

Tomado de [github/eph] (https://github.com/holatam/eph/blob/master/R/calculate_poverty.R)
]


.panel[
.panel-name[srvyuRu]
.scroll-box-12[

```r
library(srvyuRu)

load_base.(
 .dir = here::here(
   "P_2019_Terceros.sav"
 )
) %&gt;%
load_recipes_ech.(
 .ech = "2019",
 .recipe = "labor"
) %&gt;%
set_weight.(
  .weight = "pesoano"
) %&gt;%
stats_ratio.(
  po,
  pd,
  .by = c("nomdpto","e26")
)
```
]
]

.panel[
.panel-name[srvyuRu (2)]

.scroll-box-12[

```r
library(srvyuRu)

load_base.(
 .dir = here::here(
   "P_2019_Terceros.sav"
 )
) %&gt;%
estimate_labor_indicators.(
 .ech = "2019",
 .by = c("nomdpto","e26")
)
```
]


]


.panel[
.panel-name[srvyuRu (3)]

.scroll-box-12[


```r
wl.Series &lt;- get_series.(
  srvy_name = list(
    ech_2011 = "data-raw/ech/P_2011_TERCEROS.sav",
    ech_2012 = "data-raw/ech/P_2012_TERCEROS.sav",
    ech_2013 = "data-raw/ech/P_2013_Terceros.sav",
    ech_2014 = "data-raw/ech/P_2014_Terceros.sav",
    ech_2015 = "data-raw/ech/P_2015_Terceros.sav",
    ech_2016 = "data-raw/ech/P_2016_Terceros.sav",
    ech_2017 = "data-raw/ech/P_2017_Terceros.sav",
    ech_2018 = "data-raw/ech/P_2018_Terceros.sav",
    ech_2019 = "data-raw/ech/P_2019_Terceros.sav",
    ech_2020 = "data-raw/ech/HyP_2020_Terceros.sav",
    ech_2021 = c(
        "data-raw/ech/ECH_2021_sem1_terceros.csv",
        "data-raw/ech/ECH_07_2021.csv",
        "data-raw/ech/ECH_08_2021.csv",
        "data-raw/ech/ECH_09_2021.csv",
        "data-raw/ech/ECH_10_2021.csv",
        "data-raw/ech/ECH_11_2021.csv",
        "data-raw/ech/ech_12_2021.csv"
      )
    ),
  type = "ech",
  easy_fun = "labor_indicators",
  by = "genre"
)
```

]


]


.panel[
.panel-name[Impelementación]

.scroll-box-12[

```r
srvyuRu::load_recipes_ech.
```

```
## Welcome!
```

```
## function (.data, .ech, .recipe, zap_labels = TRUE) 
## {
##     message(crayon::green(glue::glue("Se cargó la receta {.recipe} de la ECH edición {.ech}")))
##     recipes %&gt;% filter.(edicion == {
##         {
##             .ech
##         }
##     }, tipo == {
##         {
##             .recipe
##         }
##     }) %&gt;% pull.(receta) %&gt;% rlang::parse_expr() %&gt;% rlang::eval_tidy()
## }
## &lt;bytecode: 0x0000024ec2e577b0&gt;
## &lt;environment: namespace:srvyuRu&gt;
```

```r
srvyuRu::load_recipes_from_db.
```

```
## function (.data, .cnn, .survey, .ed, .recipe) 
## {
##     message(crayon::green(glue::glue("Cargando receta {.recipe} de la {.survey} edición {.ed}")))
##     DBI::dbGetQuery({
##         {
##             .cnn
##         }
##     }, "SELECT *\n        FROM datamart_innovacion.aux_recetas\n        WHERE edicion = $1 AND tipo = $2", 
##         params = c({
##             {
##                 .ed
##             }
##         }, {
##             {
##                 .recipe
##             }
##         })) %&gt;% data.table::data.table() %&gt;% pull.(receta) %&gt;% 
##         rlang::parse_expr() %&gt;% rlang::eval_tidy()
## }
## &lt;bytecode: 0x0000024ec2eaea58&gt;
## &lt;environment: namespace:srvyuRu&gt;
```

]
]

]


---

class: header_background

# Metaprogramación

- ## Code can generate code

.panelset[
.panel[.panel-name[Crear recetas]

.scroll-box-12[

```r
srvyuRu::new_recipe
```

```
## function (.type, .ed, .formula, ...) 
## {
##     .formula &lt;- enquo(.formula)
##     dots &lt;- list2(...)
##     args &lt;- pairlist2(.df = , .type = , .ed = )
##     expr &lt;- glue::glue(".df %&gt;% {.formula}")
##     rlang::new_function(args, body = expr[2], env = .GlobalEnv)
## }
## &lt;bytecode: 0x0000024ec310f378&gt;
## &lt;environment: namespace:srvyuRu&gt;
```

]

No me convence **rlang**

]


.panel[.panel-name[Mercado de trabajo]
.scroll-box-12[

```r
mercado_trabajo &lt;- srvyuRu::new_recipe(
  .type = "ech",
  .ed = 2006:2021,
  steps = srvyuRu::steps(
    srvyuRu::step_recode(
      pet,
      as.numeric(
        pobpcoac != 1
      )
    ),
    srvyuRu::step_recode(
      po,
      as.numeric(
        pobpcoac == 2
      )
    ),
    srvyuRu::step_recode(
      pd,
      as.numeric(
        pobpcoac %in% 3:5
      )
    )
  )
)
```

]

La receta fue tomada del paquete **ech** del cual me inspire.

]

.panel[.panel-name[Informalidad]
.scroll-box-12[


```r
# Aporte de Fabricio Machado

mercado_trabajo &lt;- mercado_trabajo %&gt;% add_steps(
  srvyuRu::step_recode(
    inf,
    as.numeric(
      f82 == 1
    )
  ),
  srvyuRu::step_recode(
    cp,
    as.numeric(f73 %in% 5:6)
  )
)
```

]


**add_steps** gran uso de memoria


]

]

---

class: header_background

# Algunas recetas

- ## &lt;font color = #00000&gt; Encuesta de actividades de innovación: &lt;font&gt;
  - **Porcentaje de empresas que realizan innovación**
  - **Porcentaje de empresas que realizan innovación por tipo de actividad**
  - **Inversión en actividades de innovación**
  - ...
- ## &lt;font color = #00000&gt; Encuesta continua de hogares &lt;font&gt;
  - **Mercado de trabajo**
  - **Brecha de género en el mercado de trabajo**
  - **Nivel educativo máximo alcanzado**

---

class: header_background

# Justificación de uso público

- ## &lt;font color = #00000&gt; Existen los microdatos, gente que sabe R, gente explota al máximo el uso de encuestas, gente que sabe de muestreo, pero cuantos saben de todas?&lt;font&gt;
- ## &lt;font color = #00000&gt; Uso de software no libres &lt;font&gt;
- ## &lt;font color = #00000&gt; Reproducibibilidad de resultados &lt;font&gt;
- ## &lt;font color = #00000&gt; Mantenimiento en el tiempo &lt;font&gt;


---

class: header_background

# Ej: Innovación por tipo

.scroll-box-20[


```r
innovacion_tipo &lt;- srvyuRu::new_recipe(
  .type = "eai",
  steps = srvyuRu::steps(
    srvyuRu::step_recode(
      producto,
      srvyuRu::if_any(
        d_111a,
        d_121a,
        d_131a,
        d_141a,
        d_151a,
        d_161a
      ) ~ .x == 1,
      .ed = "1998-2000"
    ),
    srvyuRu::step_recode(
      proceso,
      srvyuRu::if_any(
        d_112a,
        d_122a,
        d_132a,
        d_142a,
        d_152a,
        d_162a,
        d_113a,
        d_123a,
        d_133a,
        d_143a,
        d_153a,
        d_163a,
        d_114a,
        d_124a,
        d_134a,
        d_144a,
        d_154a,
        d_164a
      ) ~ .x == 1,
      .ed = "1998-2000"
    ),
    srvyuRu::step_recode(
      producto,
      as.numeric(e1_1a == 1),
      .ed = "2001-2003"
    ),
    srvyuRu::step_recode(
      proceso,
      if_any(
        e1_2a,
        e1_3a,
        e1_4a
      ) ~ .x == 1,
      .ed = "2001-2003"
    ),
    srvyuRu::step_recode(
      producto,
      as.numeric(E_1_1_A == 1),
      .ed = c(
        "2004-2006",
        "2007-2009"
      )
    ),
    srvyuRu::step_recode(
      proceso,
      srvyuRu::if_any(
        E_1_2_A,
        E_1_3_A,
        E_1_4_A
      ) ~ .x == 1,
      .ed = c(
        "2004-2006",
        "2007-2009"
      )
    ),
    srvyuRu::step_recode(
      producto,
      as.numeric(E1_1_1 == 1),
      .ed = c(
        "2010-2012",
        "2013-2015"
      )
    ),
    srvyuRu::step_recode(
      proceso,
      if_any(
        E1_2_1,
        E1_3_1,
        E1_4_1
      ) ~ .x == 1,
      .ed = c(
        "2010-2012",
        "2013-2015"
      )
    ),
    srvyuRu::step_recode(
      producto,
      as.numeric(RAI_E.1_1 == 1),
      .ed = "2016-2018"
    ),
    srvyuRu::step_recode(
      proceso,
      as.numeric(RAI_E.1_2 == 1),
      .ed = "2016-2018"
    )
  )
)
```

]


Mas ejemplos de la EAI y de la ECH, ejemplo clave la variable sexo.


---

class: inverse,middle

# srvyuRu a metaSurvey ¿¿¿...???



---

class: header_background

# Problemas de Impelementación

- ## &lt;font color = #00000&gt;  Las recetas no deberían de ser funciones... &lt;font&gt;
- ## &lt;font color = #00000&gt;  Una base de datos relacional (filas, columnas) no es lo mejor para guardar archivos JSON, si bien postgres lo soporta &lt;font&gt;
- ## &lt;font color = #00000&gt;  Un usuario público a la base de datos puede ser una buena idea, pero ... &lt;font&gt;
- ## &lt;font color = #00000&gt;  Dependencias: Chau rlang, haven, shiny* y más &lt;font&gt;
- ## &lt;font color = #00000&gt;  Formalizar conceptos sobre estimadores, varianza, estimación en áreas pequeñas, confiabilidad, un largo etc &lt;font&gt;

---


class: inverse,middle

# Por partes


- ## metaSurvey

- ## metaSurvey.api_recipes

- ## metaSurvey.api

- ## metaSurvey.interactive

---


class: header_background


# metaSurvey


.panelset[
.panel[.panel-name[Uso]

  - ### Crear, modificar, cargar recetas
  - ### Elegir diferentes 'diseños'
  - ### Funciones step_*
  - ### Funciones para esimar indicadores a lo largo del tiempo
  - ### Unificar carga de archivos con diferentes extensiones
  - ### *Enviar recetas*, *Consultar recetas*, *Visualizar recetas*
]

.panel[.panel-name[Estimaciones]


  Si bien el papel principal del **metaSurvey** es brindar apoyo en la construcción de variables, para usuarios sin experiencia en muestreo no es mala idea considerar:

  - ### Estimación de varianzas. En el caso de la **ECH** solo en las ultimas ediciones se incluyen las replicas boostrap de los ponderadores. ¿Considerar un diseño bernulli? --&gt; NO.
  - ### Estabilidad de estimaciones. Similar al paquete **calidad** se Chile que considera coeficientes de variación. --&gt;  El INE de Uruguay lo considera en sus publicaciones.
  - ### Estimadores de medias moviles para el nuevo diseño de la **ECH**


]

.panel[.panel-name[R6]


.scroll-box-18[

```r
step &lt;- R6::R6Class(
    "recipe",
    public = list(
        survey = NULL,
        edition = NULL,
        user = NULL,
        dependence = NULL,
        engine = NULL,
        initialize = function(...) {
            Map(
                f = function(item) {
                    self$add(item)
                },
                list(...)
            )
        },
        add = function(x) {
            private$recipe &lt;- c(private$recipe,list(x))
        },
        get_name = function() self$name,
        print = function(...) {
            cat("Receta ", self$get_name(), " elements\n", sep = "")
        }
    )
)
```

]
]

.panel[.panel-name[glue]


```r
glue::glue(
  ".df %&gt;%
    {fun}(
      {variable},
      {formula}
    )",
  fun = "recode",
  variable = "sexo",
  formula = "e26 == 1,'Masculino',TRUE ~ 'Femenino'"
)
```

```
## .df %&gt;%
## recode(
##   sexo,
##   e26 == 1,'Masculino',TRUE ~ 'Femenino'
## )
```


]
]



---

class: header_background

# metaSurvey.api_recipes

.vertical-center[
- ### Alojar recetas en mongoDB
- ### API con express
- ### Crear diferentes usuarios
- ### Mantenibilidad en el tiempo, no depender de PR o MR e instalación de versiones 'menores' para obtener nuevas recetas
]
---


class: header_background

# metaSurvey.api

.vertical-center[
- ### API con plumber
- ### Arrojar resultados de encuestas usando metaSurvey
- ### Visualizador de mercado de trabajo del INE
- ### Portal PRISMA de la ANII
- ### ...
]
---

class: header_background

# metaSurvey.interactive


.vertical-center[
- ### Replicar el mismo workflow de trabajo con metaSurvey pero con interfaz interactiva
- ### Widget de RStudio para usuarios de SPSS, replicando el querido 'Crear Variable'
]

---

class: header_background

# metaSurvey versión pública


.vertical-center[
  ## ¡Va a ser mi TFG!
]

---

class: header_background

# Paquetes en los que me inspire o utilice






---

.vertical-center[
  .center[
    # ¿Preguntas?
  ]
]


---

.vertical-center[
  .center[
    # Gracias!!
  ]
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"slideNumberFormat": "%current%",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
    .logo {
      background-image: url(logo.png);
      background-size: contain;
      background-repeat: no-repeat;
      position: absolute;
      top: 1em;
      right: 1em;
      width: 80px;
      height: 98px;
      z-index: 0;
    }
    </style>
    
    <script>
    document
      .querySelectorAll(
        '.remark-slide-content' +
        // add additional classes to exclude here, e.g.
        // ':not(.inverse)' +
        ':not(.hide-logo)'
      )
      .forEach(el => {
        el.innerHTML += '<div class="logo"></div>';
      });
    </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
